<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/transactions/crypto.js - Lisk JS</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Lisk JS" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2.3</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/crypto.html">crypto</a></li>
                                <li><a href="../classes/dapp.html">dapp</a></li>
                                <li><a href="../classes/delegate.html">delegate</a></li>
                                <li><a href="../classes/multisignature.html">multisignature</a></li>
                                <li><a href="../classes/signature.html">signature</a></li>
                                <li><a href="../classes/slots.html">slots</a></li>
                                <li><a href="../classes/transaction.html">transaction</a></li>
                                <li><a href="../classes/transfer.html">transfer</a></li>
                                <li><a href="../classes/vote.html">vote</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/lisk.html">lisk</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib/transactions/crypto.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Crypto module helping with cryptograhpy in Lisk Blockchain
 * @class crypto
 */

var crypto = require(&#x27;crypto-browserify&#x27;);
var constants = require(&#x27;../constants.js&#x27;);

if (typeof Buffer === &#x27;undefined&#x27;) {
	Buffer = require(&#x27;buffer/&#x27;).Buffer;
}

var ByteBuffer = require(&#x27;bytebuffer&#x27;);
var bignum = require(&#x27;browserify-bignum&#x27;);
var naclFactory = require(&#x27;js-nacl&#x27;);

var naclInstance;
naclFactory.instantiate(function (nacl) {
	naclInstance = nacl;
});

/**
 * &#x60;fixedPoint&#x60; is the size we calculate numbers in. 10^8
 * @property fixedPoint
 * @static
 * @final
 * @type Number
 */

var fixedPoint = Math.pow(10, 8);


/**
 * @method getSignatureBytes
 * @param signature
 * @return {typed array}
 */

function getSignatureBytes(signature) {
	var bb = new ByteBuffer(32, true);
	var publicKeyBuffer = new Buffer(signature.publicKey, &#x27;hex&#x27;);

	for (var i = 0; i &lt; publicKeyBuffer.length; i++) {
		bb.writeByte(publicKeyBuffer[i]);
	}

	bb.flip();
	return new Uint8Array(bb.toArrayBuffer());
}

/**
 * @method getDAppBytes
 * @param dapp Object
 * @return {buffer}
 */

function getDAppBytes(dapp) {
	try {
		var buf = new Buffer([]);
		var nameBuf = new Buffer(dapp.name, &#x27;utf8&#x27;);
		buf = Buffer.concat([buf, nameBuf]);

		if (dapp.description) {
			var descriptionBuf = new Buffer(dapp.description, &#x27;utf8&#x27;);
			buf = Buffer.concat([buf, descriptionBuf]);
		}

		if (dapp.tags) {
			var tagsBuf = new Buffer(dapp.tags, &#x27;utf8&#x27;);
			buf = Buffer.concat([buf, tagsBuf]);
		}

		if (dapp.link) {
			buf = Buffer.concat([buf, new Buffer(dapp.link, &#x27;utf8&#x27;)]);
		}

		if (dapp.icon) {
			buf = Buffer.concat([buf, new Buffer(dapp.icon, &#x27;utf8&#x27;)]);
		}

		var bb = new ByteBuffer(4 + 4, true);
		bb.writeInt(dapp.type);
		bb.writeInt(dapp.category);
		bb.flip();

		buf = Buffer.concat([buf, bb.toBuffer()]);
	} catch (e) {
		throw Error(e.toString());
	}

	return buf;
}

/**
 * @method getTransferBytes
 * @param dapptransfer
 * @return {buffer}
 */

function getTransferBytes(dapptransfer) {
	try {
		var buf = new Buffer([]);
		var nameBuf = new Buffer(dapptransfer.dappid, &#x27;utf8&#x27;);
		buf = Buffer.concat([buf, nameBuf]);
	} catch (e) {
		throw Error(e.toString());
	}

	return buf;
}

/**
 * @method getBytes
 * @param transaction Object
 * @param skipSignature boolean
 * @param skipSecondSignature boolean
 *
 * @return {buffer}
 */

function getBytes(transaction, skipSignature, skipSecondSignature) {
	var assetSize = 0,
		assetBytes = null;

	switch (transaction.type) {
		case 1: // Signature
			assetSize = 32;
			assetBytes = getSignatureBytes(transaction.asset.signature);
			break;

		case 2: // Delegate
			assetBytes = new Buffer(transaction.asset.delegate.username, &#x27;utf8&#x27;);
			assetSize = assetBytes.length;
			break;

		case 3: // Vote
			if (transaction.asset.votes !== null) {
				assetBytes = new Buffer(transaction.asset.votes.join(&#x27;&#x27;), &#x27;utf8&#x27;);
				assetSize = assetBytes.length;
			}
			break;

		case 4: // Multi-Signature
			var keysgroupBuffer = new Buffer(transaction.asset.multisignature.keysgroup.join(&#x27;&#x27;), &#x27;utf8&#x27;);
			var bb = new ByteBuffer(1 + 1 + keysgroupBuffer.length, true);

			bb.writeByte(transaction.asset.multisignature.min);
			bb.writeByte(transaction.asset.multisignature.lifetime);

			for (var i = 0; i &lt; keysgroupBuffer.length; i++) {
				bb.writeByte(keysgroupBuffer[i]);
			}

			bb.flip();

			assetBytes = bb.toBuffer();
			assetSize  = assetBytes.length;
			break;

		case 5: // Dapp
			assetBytes = getDAppBytes(transaction.asset.dapp);
			assetSize = assetBytes.length;
			break;

		case 6: // Dapp Transfer
			assetBytes = getTransferBytes(transaction.asset.dapptransfer);
			assetSize = assetBytes.length;
			break;
	}

	var bb = new ByteBuffer(1 + 4 + 32 + 8 + 8 + 64 + 64 + assetSize, true);

	bb.writeByte(transaction.type);
	bb.writeInt(transaction.timestamp);

	var senderPublicKeyBuffer = new Buffer(transaction.senderPublicKey, &#x27;hex&#x27;);
	for (var i = 0; i &lt; senderPublicKeyBuffer.length; i++) {
		bb.writeByte(senderPublicKeyBuffer[i]);
	}

	if (transaction.requesterPublicKey) {
		var requesterPublicKey = new Buffer(transaction.requesterPublicKey, &#x27;hex&#x27;);

		for (var i = 0; i &lt; requesterPublicKey.length; i++) {
			bb.writeByte(requesterPublicKey[i]);
		}
	}

	if (transaction.recipientId) {
		var recipient = transaction.recipientId.slice(0, -1);
		recipient = bignum(recipient).toBuffer({size: 8});

		for (var i = 0; i &lt; 8; i++) {
			bb.writeByte(recipient[i] || 0);
		}
	} else {
		for (var i = 0; i &lt; 8; i++) {
			bb.writeByte(0);
		}
	}

	bb.writeLong(transaction.amount);

	if (assetSize &gt; 0) {
		for (var i = 0; i &lt; assetSize; i++) {
			bb.writeByte(assetBytes[i]);
		}
	}

	if (!skipSignature &amp;&amp; transaction.signature) {
		var signatureBuffer = new Buffer(transaction.signature, &#x27;hex&#x27;);
		for (var i = 0; i &lt; signatureBuffer.length; i++) {
			bb.writeByte(signatureBuffer[i]);
		}
	}

	if (!skipSecondSignature &amp;&amp; transaction.signSignature) {
		var signSignatureBuffer = new Buffer(transaction.signSignature, &#x27;hex&#x27;);
		for (var i = 0; i &lt; signSignatureBuffer.length; i++) {
			bb.writeByte(signSignatureBuffer[i]);
		}
	}

	bb.flip();
	var arrayBuffer = new Uint8Array(bb.toArrayBuffer());
	var buffer = [];

	for (var i = 0; i &lt; arrayBuffer.length; i++) {
		buffer[i] = arrayBuffer[i];
	}

	return new Buffer(buffer);
}

/**
 * @method getId
 * @param transaction Object
 *
 * @return {string}
 */


function getId(transaction) {
	var hash = crypto.createHash(&#x27;sha256&#x27;).update(getBytes(transaction).toString(&#x27;hex&#x27;), &#x27;hex&#x27;).digest();
	var temp = new Buffer(8);
	for (var i = 0; i &lt; 8; i++) {
		temp[i] = hash[7 - i];
	}

	var id = bignum.fromBuffer(temp).toString();
	return id;
}

/**
 * @method getHash
 * @param transaction Object
 *
 * @return {string}
 */

function getHash(transaction) {
	return crypto.createHash(&#x27;sha256&#x27;).update(getBytes(transaction)).digest();
}

/**
 * @method getFee
 * @param transaction Object
 *
 * @return {number}
 */

function getFee(transaction) {
	switch (transaction.type) {
		case 0: // Normal
			return constants.fees.send;
			break;

		case 1: // Signature
			return constants.fees.signature;
			break;

		case 2: // Delegate
			return constants.fees.delegate;
			break;

		case 3: // Vote
			return constants.fees.vote;
			break;

		case 4: // Multisignature
			return constants.fees.multisignature;
			break;

		case 5: // Dapp
			return constants.fees.dapp;
			break;
	}
}

/**
 * @method sign
 * @param transaction Object
 * @param keys Object
 *
 * @return {string}
 */

function sign(transaction, keys) {
	var hash = getHash(transaction);
	var signature = naclInstance.crypto_sign_detached(hash, new Buffer(keys.privateKey, &#x27;hex&#x27;));

	if (!transaction.signature) {
		transaction.signature = new Buffer(signature).toString(&#x27;hex&#x27;);
	} else {
		return new Buffer(signature).toString(&#x27;hex&#x27;);
	}
}

/**
 * @method secondSign
 * @param transaction Object
 * @param keys Object
 *
 * @return {string}
 */

function secondSign(transaction, keys) {
	var hash = getHash(transaction);
	var signature = naclInstance.crypto_sign_detached(hash, new Buffer(keys.privateKey, &#x27;hex&#x27;));
	transaction.signSignature = new Buffer(signature).toString(&#x27;hex&#x27;)
}

/**
 * @method multiSign
 * @param transaction Object
 * @param keys Object
 *
 * @return {string}
 */

function multiSign(transaction, keys) {
	var bytes = getBytes(transaction, true, true);
	var hash = crypto.createHash(&#x27;sha256&#x27;).update(bytes).digest();
	var signature = naclInstance.crypto_sign_detached(hash, new Buffer(keys.privateKey, &#x27;hex&#x27;));

	return new Buffer(signature).toString(&#x27;hex&#x27;);
}

/**
 * @method verify
 * @param transaction Object
 *
 * @return {boolean}
 */

function verify(transaction) {
	var remove = 64;

	if (transaction.signSignature) {
		remove = 128;
	}

	var bytes = getBytes(transaction);
	var data2 = new Buffer(bytes.length - remove);

	for (var i = 0; i &lt; data2.length; i++) {
		data2[i] = bytes[i];
	}

	var hash = crypto.createHash(&#x27;sha256&#x27;).update(data2.toString(&#x27;hex&#x27;), &#x27;hex&#x27;).digest();

	var signatureBuffer = new Buffer(transaction.signature, &#x27;hex&#x27;);
	var senderPublicKeyBuffer = new Buffer(transaction.senderPublicKey, &#x27;hex&#x27;);
	var res = naclInstance.crypto_sign_verify_detached(signatureBuffer, hash, senderPublicKeyBuffer);

	return res;
}


/**
 * @method verifySecondSignature
 * @param transaction Object
 * @param publicKey Object
 *
 * @return {boolean}
 */

function verifySecondSignature(transaction, publicKey) {
	var bytes = getBytes(transaction);
	var data2 = new Buffer(bytes.length - 64);

	for (var i = 0; i &lt; data2.length; i++) {
		data2[i] = bytes[i];
	}

	var hash = crypto.createHash(&#x27;sha256&#x27;).update(data2.toString(&#x27;hex&#x27;), &#x27;hex&#x27;).digest();

	var signSignatureBuffer = new Buffer(transaction.signSignature, &#x27;hex&#x27;);
	var publicKeyBuffer = new Buffer(publicKey, &#x27;hex&#x27;);
	var res = naclInstance.crypto_sign_verify_detached(signSignatureBuffer, hash, publicKeyBuffer);

	return res;
}

/**
 * @method getKeys
 * @param secret string
 *
 * @return {object}
 */

function getKeys(secret) {
	var hash = crypto.createHash(&#x27;sha256&#x27;).update(secret, &#x27;utf8&#x27;).digest();
	var keypair = naclInstance.crypto_sign_keypair_from_seed(hash);

	return {
		publicKey : new Buffer(keypair.signPk).toString(&#x27;hex&#x27;),
		privateKey : new Buffer(keypair.signSk).toString(&#x27;hex&#x27;)
	}
}

/**
 * @method getAddress
 * @param publicKey string
 *
 * @return {string}
 */

function getAddress(publicKey) {
	var publicKeyHash = crypto.createHash(&#x27;sha256&#x27;).update(publicKey.toString(&#x27;hex&#x27;), &#x27;hex&#x27;).digest();
	var temp = new Buffer(8);

	for (var i = 0; i &lt; 8; i++) {
		temp[i] = publicKeyHash[7 - i];
	}

	var address = bignum.fromBuffer(temp).toString() + &#x27;L&#x27;;
	return address;
}

module.exports = {
	getBytes: getBytes,
	getHash: getHash,
	getId: getId,
	getFee: getFee,
	sign: sign,
	secondSign: secondSign,
	multiSign: multiSign,
	getKeys: getKeys,
	getAddress: getAddress,
	verify: verify,
	verifySecondSignature: verifySecondSignature,
	fixedPoint: fixedPoint
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
